Awesomeâ€”todayâ€™s the day to **lock the token system down** and finally get this thing **uploading, verifying, and analyzing** end-to-end.

---

## ğŸ”¥ QUICK STRATEGY: Fix the Token Flow in 3 Stages

### âœ… STAGE 1 â€” ENV VAR + SECRET KEY SYNC

**Goal**: Make sure the `JWT_SECRET` is exactly the same in **backend** and **pose-service**, and both services load it correctly.

#### âœ… 1.1. Check `.env` in both services:

Make sure both have:

```env
JWT_SECRET=super-secret-key-change-this
```

#### âœ… 1.2. Ensure they actually **use** the `.env` secret:

**In Node (Express backend)**:

```js
const JWT_SECRET = process.env.JWT_SECRET;
jwt.verify(token, JWT_SECRET);
```

**In FastAPI (pose service)**:

```py
import os
JWT_SECRET = os.getenv("JWT_SECRET", "fallback-secret")
payload = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
```

> â—ï¸**Debug tip**: Temporarily `print(JWT_SECRET)` in both services when they boot â€” confirm they match 100%.

---

### âœ… STAGE 2 â€” DEBUG TOKEN FORWARDING (Backend â†’ Pose)

**Goal**: Make sure backend sends the **exact same valid JWT** to the pose service, and the pose service accepts it.

#### âœ… 2.1. Confirm backend is passing the correct header:

In your backend, it should be:

```js
axios.post('http://localhost:8001/pose', formData, {
  headers: {
    Authorization: `Bearer ${token}`
  }
});
```

#### âœ… 2.2. Confirm the pose service reads the token:

In FastAPI:

```py
from fastapi import Header, HTTPException

def verify_token(authorization: str = Header(...)):
    try:
        scheme, token = authorization.split()
        if scheme.lower() != 'bearer':
            raise ValueError("Wrong scheme")
        payload = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        return payload
    except Exception as e:
        print(f"[AUTH ERROR] {e}")
        raise HTTPException(status_code=401, detail="Unauthorized")
```

> âœ… Add a `print(payload)` if it works, or `print(e)` if not, to make logs useful.

#### âœ… 2.3. Confirm token has a `"sub"` claim:

From backend login code, token should be created like this:

```js
jwt.sign({ sub: user.email }, process.env.JWT_SECRET, { expiresIn: '1h' });
```

---

### âœ… STAGE 3 â€” FULL TEST & LOGGING

**Goal**: Run a full test and confirm every stage logs success/failure clearly.

#### ğŸ” Log the journey:

* **Frontend**

  * âœ… Log â€œToken loaded: ...â€
  * âœ… Log response or error from upload

* **Backend**

  * âœ… Log â€œReceived token: ...â€
  * âœ… Log â€œForwarding video to pose service with token: ...â€
  * âœ… Log success/failure of call to pose

* **Pose service**

  * âœ… Log â€œReceived token: ...â€
  * âœ… Log decoded payload or error
  * âœ… Log when pose data is returned

---

## âœ… BONUS: MANUAL TOKEN TEST

To make debugging 100% precise, run a manual token test using Node:

**Create a quick `generate-token.js`:**

```js
const jwt = require('jsonwebtoken');
const token = jwt.sign({ sub: "brad@example.com" }, "super-secret-key-change-this", { expiresIn: "1h" });
console.log("JWT:", token);
```

Then take that JWT and manually test your `/pose` endpoint using `curl` or Postman:

```bash
curl -X POST http://localhost:8001/pose \
  -H "Authorization: Bearer <paste-token-here>" \
  -F "video=@/path/to/sample.mp4"
```

If that works â†’ âœ… youâ€™ve nailed the secret + decoding issue.

---

## ğŸ§­ Once That Works â€” Final Checklist

* [ ] Pose service returns JSON properly
* [ ] Backend receives + parses pose result
* [ ] Frontend handles success / error state cleanly
* [ ] LocalStorage keeps token on reload
* [ ] Add logout button
* [ ] Full MVP upload + analysis works ğŸ¯

---

Letâ€™s start with **JWT secret sync + pose service logs**. Drop any logs or errors you get here, and Iâ€™ll help you instantly debug.

Ready when you are.
